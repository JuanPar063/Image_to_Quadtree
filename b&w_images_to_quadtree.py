# -*- coding: utf-8 -*-
"""B&W_Images_to_quadtree.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Skl8ynhGU6OzWDMwZmZ5MP-uZOfmH0FD
"""

from os import path
from PIL import Image
import numpy as np
import os
from functools import partial  # For partial function application


def matriz_a_imagen(matriz, nombre_archivo):
    # Tamaño de la matriz
    altura = len(matriz)
    anchura = len(matriz[0])

    # Crear una nueva imagen con el mismo tamaño que la matriz
    imagen = Image.new("RGB", (anchura, altura), "white")

    # Convertir la matriz en una imagen
    for y in range(altura):
        for x in range(anchura):
            if matriz[y][x] == 1:
                imagen.putpixel((x, y), (0, 0, 0))  # Pixel negro
            else:
                imagen.putpixel((x, y), (255, 255, 255))  # Pixel blanco

    # Guardar la imagen
    imagen.save(nombre_archivo)

class NodoQuadtree:
    def __init__(self):
        self.valor = 0
        self.hijos = [None, None, None, None]  # Cuatro hijos: superior-izquierda, superior-derecha, inferior-izquierda, inferior-derecha

def insertar_en_quadtree(raiz, ruta, valor):
    if len(ruta) == 0:
        raiz.valor = valor
        return

    indice = int(ruta[0]) - 1  # Restar 1 para que los índices estén en el rango 0-3
    if indice < 0 or indice > 3:
        raise ValueError("La ruta contiene un índice inválido")

    if raiz.hijos[indice] is None:
        raiz.hijos[indice] = NodoQuadtree()
    insertar_en_quadtree(raiz.hijos[indice], ruta[1:], valor)

def crear_quadtree(rutas):
    raiz = NodoQuadtree()
    for ruta in rutas:
        insertar_en_quadtree(raiz, ruta, 1)
    return raiz

def quadtree_a_matriz(raiz, matriz, fila_inicio, fila_fin, col_inicio, col_fin):
    if raiz is None:
        return

    # Calcular el valor a asignar a la matriz
    valor = raiz.valor

    # Si la raíz tiene hijos, dividir el espacio en cuartos
    if any(hijo is not None for hijo in raiz.hijos):
        fila_medio = (fila_inicio + fila_fin) // 2
        col_medio = (col_inicio + col_fin) // 2

        # Recorrer los cuatro hijos y llamar recursivamente
        quadtree_a_matriz(raiz.hijos[0], matriz, fila_inicio, fila_medio, col_inicio, col_medio)  # Superior-izquierda
        quadtree_a_matriz(raiz.hijos[1], matriz, fila_inicio, fila_medio, col_medio + 1, col_fin)  # Superior-derecha
        quadtree_a_matriz(raiz.hijos[2], matriz, fila_medio + 1, fila_fin, col_inicio, col_medio)  # Inferior-izquierda
        quadtree_a_matriz(raiz.hijos[3], matriz, fila_medio + 1, fila_fin, col_medio + 1, col_fin)  # Inferior-derecha
    else:
        # Si la raíz no tiene hijos, asignar el valor a todos los elementos de la submatriz
        for i in range(fila_inicio, fila_fin + 1):
            for j in range(col_inicio, col_fin + 1):
                matriz[i][j] = valor

def crear_matriz_quadtree(raiz, tamano):
    # Inicializar la matriz con ceros
    matriz = [[0] * tamano for _ in range(tamano)]

    # Convertir el quadtree en matriz
    quadtree_a_matriz(raiz, matriz, 0, tamano - 1, 0, tamano - 1)

    return matriz


def ingresar_tamaño():
    while True:
        try:
            tamaño = int(input("Ingrese el tamaño de la matriz: "))
            if tamaño <= 0:
                raise ValueError
            break
        except ValueError:
            print("Tamaño inválido. Por favor, ingrese un número entero mayor que 0.")
    return tamaño


class Node:
    def __init__(self, value, children=None):
        self.value = value
        self.children = children if children else []  # Ensure children is always a list

def image_to_matrix(image_path, threshold=128):
    # Open the image
    img = Image.open(image_path)
    # Convert to grayscale (if necessary)
    img = img.convert('L')
    # Convert to numpy array
    matrix = np.array(img)
    # Apply thresholding
    matrix = (matrix < threshold).astype(int)
    return matrix

def build_quadtree(matrix):
    if len(matrix) == 0 or len(matrix[0]) == 0:
        return None
    n = len(matrix)
    if n == 1:
        return Node(matrix[0][0])
    mid = n // 2
    nw = [row[:mid] for row in matrix[:mid]]
    ne = [row[mid:] for row in matrix[:mid]]
    sw = [row[:mid] for row in matrix[mid:]]
    se = [row[mid:] for row in matrix[mid:]]
    children = [build_quadtree(nw), build_quadtree(ne), build_quadtree(sw), build_quadtree(se)]
    # Filter empty sub-nodes
    children = [child for child in children if child is not None]
    return Node(1, children)

def quadtree_to_image(node, n):
    # Initialize empty matrix
    matrix = [['0' for _ in range(n)] for _ in range(n)]

    # Use a stack for iterative processing
    stack = [(node, 0, 0, n)]
    while stack:
        node, x, y, length = stack.pop()
        if node.value == 1 and not node.children:
            # Leaf node with value 1: fill corresponding area with 1s
            for i in range(x, x + length):
                for j in range(y, y + length):
                    matrix[i][j] = '1'
        elif node.children:
            mid = length // 2
            # Recursively process children using stack
            if len(node.children) > 0:
                stack.append((node.children[0], x, y, mid))
            if len(node.children) > 1:
                stack.append((node.children[1], x, y + mid, mid))
            if len(node.children) > 2:
                stack.append((node.children[2], x + mid, y, mid))
            if len(node.children) > 3:
                stack.append((node.children[3], x + mid, y + mid, mid))

    return matrix

def paths_to_matrix(paths, size):

    matrix = np.zeros((size, size), dtype=np.uint8)  # Initialize with zeros (white pixels)
    for path in paths:
        # Check for invalid characters
        if any(char not in ('0', '1') for char in path):
            raise ValueError(f"Invalid character in path: {path}")

        # Convert path to binary representation (assuming 0-based indexing)
        binary_path = format(int(path, len(path)), f"0{len(path) * 2}b")

        # Traverse the path and set corresponding pixels to 1 (black)
        row, col = 0, 0
        for bit in binary_path:
            if bit == '1':
                matrix[row][col] = 1
            row = row + (col & 1)
            col = col >> 1
    print(matrix)
    return matrix


def matrix_to_image(matrix, output_path):
    # Convert the matrix to a numpy array
    matrix = np.array(matrix, dtype=np.uint8)

    # Multiply by 255 to get pixel values in the range 0-255
    # because PIL Image.fromarray() expects pixel values in this range
    matrix *= 255

    # Create a PIL Image object from the numpy array
    image = Image.fromarray(matrix)

    # Save the image to the specified output path
    image.save(output_path)

def get_paths(node):
    if node is None:
        return []
    if node.value == 1 and not node.children:
        return ['']  # Empty path for a leaf node with value 1
    paths = []
    for i, child in enumerate(node.children):
        child_paths = get_paths(child)
        # Prepend the child index (converted to string) to each child's path
        paths.extend([str(i + 1) + path for path in child_paths])
    return paths


def path_to_quadtree(path, size):

    if not path.isdigit():
      path = ""
    # Initialize root node
    root = Node(1)

    # Initialize stack with root node
    stack = [(root, 0)]

    # Iterate over characters in the path
    for char in path:

        # Calculate child index based on character
        index = int(char) - 1

        # Pop the current node and level from the stack
        current_node, level = stack.pop()

        # Ensure enough children exist
        while len(current_node.children) <= index:
            current_node.children.append(Node(1))

        # Move to the child node
        child_node = current_node.children[index]

        # If reaching the end of a sub-tree, reset to root
        if level == size - 1:
            child_node.value = 1
            stack.append((root, 0))
        else:
            stack.append((child_node, level + 1))

    return root

def base5_a_base10(lista_base5):
    # Convertir la lista de números base 5 a base 10
    lista_base10 = []
    for numero_base5 in lista_base5:
        numero_base10 = 0
        potencia = 0
        for digito in reversed(numero_base5):
            numero_base10 += int(digito) * (5 ** potencia)
            potencia += 1
        lista_base10.append(numero_base10)
    return lista_base10

def base10_a_base5(lista_base10):
    # Convertir la lista de números base 10 a base 5
    lista_base5 = []
    for numero_base10 in lista_base10:
        if numero_base10 == 0:
            lista_base5.append("0")
            continue

        numero_base5 = ""
        while numero_base10 > 0:
            residuo = numero_base10 % 5
            numero_base5 = str(residuo) + numero_base5
            numero_base10 //= 5
        lista_base5.append(numero_base5)
    return lista_base5

def path_to_matrix(path, size):
    # Initialize the matrix with zeros
    matrix = [[0 for _ in range(size)] for _ in range(size)]

    # Split the path into individual nodes
    nodes = path.split()

    # Iterate over each node in the path
    for node in nodes:
        # Calculate the row and column indices of the node in the matrix
        row = int(node[0]) - 1
        col = int(node[1]) - 1 if len(node) > 1 else 0
        # Set the corresponding element in the matrix to 1
        matrix[row][col] = 1

    return matrix

def open_image(filepath):

    try:
        return Image.open(filepath)
    except FileNotFoundError:
        return None


def main():
    while True:
        print("Menu:")
        print("1. Ver rutas de raíz a hoja dando la ruta de un archivo de tipo imagen")
        print("2. Ingresar rutas de raíz a hoja de una imagen para generar la imagen")
        print("3. Salir")

        choice = input("Ingrese su opción: ")

        if choice == "1":
            # Opción para ver las rutas de raíz a hoja dando la ruta de un archivo de tipo imagen
            image_path = input("Ingrese la ruta de la imagen: ")
            matrix = image_to_matrix(image_path)
            quadtree = build_quadtree(matrix)
            paths = get_paths(quadtree)
            print("Rutas de raíz a hoja:")
            paths = base5_a_base10(paths)
            ruta = ' '.join(map(str, paths))
            print(ruta)

        elif choice == "2":
            ruta_str = input("Ingrese las rutas separadas por espacios: ")
            rutas = ruta_str.split()
            rutas = list(map(int, rutas))

            rutas = base10_a_base5(rutas)
            tamaño = ingresar_tamaño()

            quadtree = crear_quadtree(rutas)
            matriz = crear_matriz_quadtree(quadtree, tamaño)


            nombre_archivo = "imagen_final.png"
            matriz_a_imagen(matriz, nombre_archivo)
            print(f"La imagen se ha guardado como '{nombre_archivo}'")

        elif choice == "3":
            # Opción para salir del programa
            print("Fin del programa.")
            break

        else:
            print("Opción no válida. Por favor, elija una opción válida.")


if __name__ == "__main__":
    main()